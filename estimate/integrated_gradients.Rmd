---
title: "Visualization Integrated Gradients"
output: rmdformats::readthedown
css: custom.css
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This notebook visualizes the integrated gradients saved in
`integrated_gradients.ipynb`. We first setup our notebook with libraries and
visualization-specific parameters.

```{r}
library(tidyverse)
library(glue)
theme_set(theme_classic())
set.seed(20240203)

n_taxa <- 144
n_timepoints <- 50
tax_id <- "tax21"
```

We next read in and lighltly process the integrated gradient attributions along
with the original data, onto which we'll overlay the explanations.

```{r}
feature_names <- apply(expand.grid(glue("tax{1:n_taxa}"), as.character(1:n_timepoints)), 1, paste, collapse = "_")
attributions <- read_csv("data/attributions.csv") |>
  set_names(feature_names)

blooms <- read_csv("data/blooms.csv")
classes <- blooms |>
  select(subject, class) |>
  unique() |>
  pull(class)
```

We can visualize all the gradients simultaneously by generating a heatmap. To
order attributions (so that similar rows go near to one another), we'll use the
leaf ordering from a hierarchical clustering. This ordering is saved in
`hclust_res`.

```{r}
attr_subset <- attributions |>
  mutate(subject = row_number(), class = classes[1:63]) |>
  select(subject, class, starts_with(tax_id))

hclust_res <- attr_subset |>
  select(starts_with("tax")) |>
  dist() |>
  hclust()

attr_subset |>
  pivot_longer(-subject:-class, names_to = "feature") |>
  separate(feature, c("taxon", "timepoint")) |>
  mutate(
    timepoint = as.integer(str_extract(timepoint, "[0-9]+")),
    subject = factor(subject, hclust_res$order)
  ) |>
  ggplot() +
  geom_tile(aes(timepoint, subject, fill = value)) +
  scale_fill_gradient2() +
  scale_x_continuous(expand = c(0, 0))
```

Alternatively, we can overlay the gradients onto the original data, but just for
a subset of samples and taxa. The taxa filtering is done in the block below.

```{r}
attr75 <- attributions |>
  mutate(subject = glue("subject_{row_number()}")) |>
  pivot_longer(-subject, names_to = "feature", values_to = "attribution") |>
  filter(str_detect(feature, tax_id)) |>
  mutate(time = as.integer(str_extract(feature, "[0-9]+$")))
```

Next, we filter the samples and visualize the combined original data
(`geom_line`) and gradient overlays (`geom_point`).

```{r}
subset_str <- glue("subject_{c(6, 63, hclust_res$order[seq(2, 62, length.out = 6)])}")
blooms |>
  filter(subject %in% subset_str) |>
  select(subject, class, starts_with(tax_id)) |>
  pivot_longer(starts_with(tax_id), values_to = "Freq", names_to = "feature") |>
  left_join(attr75) |>
  mutate(
    subject = str_remove(subject, "subject_"),
    subject = factor(subject, str_remove(subset_str, "subject_"))
  ) |>
  ggplot(aes(time, Freq)) +
  geom_line(aes(group = subject, col = class), linewidth = 0.9) +
  scale_color_manual(values = c("#730739", "#4BA68C")) +
  geom_point(aes(size = abs(attribution), shape = attribution > 0)) +
  scale_size_area(max_size = 16, guide = "none") +
  scale_shape_manual(values = c(95, 43), guide = "none") +
  facet_wrap(~subject, scales = "free_y", nrow = 2) +
  labs(x = "Time", y = "Abundance", title = "IG for Species 21") +
  theme(strip.text.y = element_text(angle = 0))

# ggsave("data/integrated_gradients.png", width = 8, height = 3)
```
